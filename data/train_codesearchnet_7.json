[{"idx": 1, "doc": "Return either the full or truncated version of a QIIME - formatted taxonomy string .", "code": "def split_phylogeny ( p , level = \"s\" ) : level = level + \"__\" result = p . split ( level ) return result [ 0 ] + level + result [ 1 ] . split ( \";\" ) [ 0 ]", "label": 1}, {"idx": 2, "doc": "Check to make sure the supplied directory path does not exist if so create it . The method catches OSError exceptions and returns a descriptive message instead of re - raising the error .", "code": "def ensure_dir ( d ) : if not os . path . exists ( d ) : try : os . makedirs ( d ) except OSError as oe : # should not happen with os.makedirs # ENOENT: No such file or directory if os . errno == errno . ENOENT : msg = twdd ( \"\"\"One or more directories in the path ({}) do not exist. If                            you are specifying a new directory for output, please ensure                            all other directories in the path currently exist.\"\"\" ) return msg . format ( d ) else : msg = twdd ( \"\"\"An error occurred trying to create the output directory                            ({}) with message: {}\"\"\" ) return msg . format ( d , oe . strerror )", "label": 1}, {"idx": 3, "doc": "Takes either a file path or an open file handle checks validity and returns an open file handle or raises an appropriate Exception .", "code": "def file_handle ( fnh , mode = \"rU\" ) : handle = None if isinstance ( fnh , file ) : if fnh . closed : raise ValueError ( \"Input file is closed.\" ) handle = fnh elif isinstance ( fnh , str ) : handle = open ( fnh , mode ) return handle", "label": 1}, {"idx": 4, "doc": "Find the user specified categories in the map and create a dictionary to contain the relevant data for each type within the categories . Multiple categories will have their types combined such that each possible combination will have its own entry in the dictionary .", "code": "def gather_categories ( imap , header , categories = None ) : # If no categories provided, return all SampleIDs if categories is None : return { \"default\" : DataCategory ( set ( imap . keys ( ) ) , { } ) } cat_ids = [ header . index ( cat ) for cat in categories if cat in header and \"=\" not in cat ] table = OrderedDict ( ) conditions = defaultdict ( set ) for i , cat in enumerate ( categories ) : if \"=\" in cat and cat . split ( \"=\" ) [ 0 ] in header : cat_name = header [ header . index ( cat . split ( \"=\" ) [ 0 ] ) ] conditions [ cat_name ] . add ( cat . split ( \"=\" ) [ 1 ] ) # If invalid categories or conditions identified, return all SampleIDs if not cat_ids and not conditions : return { \"default\" : DataCategory ( set ( imap . keys ( ) ) , { } ) } #If only category column given, return column-wise SampleIDs if cat_ids and not conditions : for sid , row in imap . items ( ) : cat_name = \"_\" . join ( [ row [ cid ] for cid in cat_ids ] ) if cat_name not in table : table [ cat_name ] = DataCategory ( set ( ) , { } ) table [ cat_name ] . sids . add ( sid ) return table # Collect all condition names cond_ids = set ( ) for k in conditions : try : cond_ids . add ( header . index ( k ) ) except ValueError : continue idx_to_test = set ( cat_ids ) . union ( cond_ids ) # If column name and condition given, return overlapping SampleIDs of column and # condition combinations for sid , row in imap . items ( ) : if all ( [ row [ header . index ( c ) ] in conditions [ c ] for c in conditions ] ) : key = \"_\" . join ( [ row [ idx ] for idx in idx_to_test ] ) try : assert key in table . keys ( ) except AssertionError : table [ key ] = DataCategory ( set ( ) , { } ) table [ key ] . sids . add ( sid ) try : assert len ( table ) > 0 except AssertionError : return { \"default\" : DataCategory ( set ( imap . keys ( ) ) , { } ) } else : return table", "label": 1}, {"idx": 5, "doc": "Parses the unifrac results file into a dictionary", "code": "def parse_unifrac ( unifracFN ) : with open ( unifracFN , \"rU\" ) as uF : first = uF . next ( ) . split ( \"\\t\" ) lines = [ line . strip ( ) for line in uF ] unifrac = { \"pcd\" : OrderedDict ( ) , \"eigvals\" : [ ] , \"varexp\" : [ ] } if first [ 0 ] == \"pc vector number\" : return parse_unifrac_v1_8 ( unifrac , lines ) elif first [ 0 ] == \"Eigvals\" : return parse_unifrac_v1_9 ( unifrac , lines ) else : raise ValueError ( \"File format not supported/recognized. Please check input \" \"unifrac file.\" )", "label": 1}, {"idx": 6, "doc": "Function to parse data from older version of unifrac file obtained from Qiime version 1 . 8 and earlier .", "code": "def parse_unifrac_v1_8 ( unifrac , file_data ) : for line in file_data : if line == \"\" : break line = line . split ( \"\\t\" ) unifrac [ \"pcd\" ] [ line [ 0 ] ] = [ float ( e ) for e in line [ 1 : ] ] unifrac [ \"eigvals\" ] = [ float ( entry ) for entry in file_data [ - 2 ] . split ( \"\\t\" ) [ 1 : ] ] unifrac [ \"varexp\" ] = [ float ( entry ) for entry in file_data [ - 1 ] . split ( \"\\t\" ) [ 1 : ] ] return unifrac", "label": 1}, {"idx": 7, "doc": "Function to parse data from newer version of unifrac file obtained from Qiime version 1 . 9 and later .", "code": "def parse_unifrac_v1_9 ( unifrac , file_data ) : unifrac [ \"eigvals\" ] = [ float ( entry ) for entry in file_data [ 0 ] . split ( \"\\t\" ) ] unifrac [ \"varexp\" ] = [ float ( entry ) * 100 for entry in file_data [ 3 ] . split ( \"\\t\" ) ] for line in file_data [ 8 : ] : if line == \"\" : break line = line . split ( \"\\t\" ) unifrac [ \"pcd\" ] [ line [ 0 ] ] = [ float ( e ) for e in line [ 1 : ] ] return unifrac", "label": 1}, {"idx": 8, "doc": "Determine color - category mapping . If color_column was specified then map the category names to color values . Otherwise use the palettable colors to automatically generate a set of colors for the group values .", "code": "def color_mapping ( sample_map , header , group_column , color_column = None ) : group_colors = OrderedDict ( ) group_gather = gather_categories ( sample_map , header , [ group_column ] ) if color_column is not None : color_gather = gather_categories ( sample_map , header , [ color_column ] ) # match sample IDs between color_gather and group_gather for group in group_gather : for color in color_gather : # allow incomplete assignment of colors, if group sids overlap at # all with the color sids, consider it a match if group_gather [ group ] . sids . intersection ( color_gather [ color ] . sids ) : group_colors [ group ] = color else : bcolors = itertools . cycle ( Set3_12 . hex_colors ) for group in group_gather : group_colors [ group ] = bcolors . next ( ) return group_colors", "label": 1}]